/* global globalThis */
/**
 * This file implements helpers and relevant types for use with `wasi:http` 0.2.x APIs
 *
 * @see: https://github.com/WebAssembly/wasi-http
 */

import { IncomingBody, IncomingRequest, Method } from "wasi:http/types@0.2.6";
import { Pollable } from "wasi:io/poll@0.2.6";
import { InputStream } from "wasi:io/streams@0.2.6";

const DEFAULT_INCOMING_BODY_READ_MAX_BYTES = 4096n;

/** Get the global `Request` */
function ensureGlobalRequest() {
    if (!globalThis.Request) {
        throw new TypeError('Request not provided by platform');
    }
    return globalThis.Request;
}

/** Get the global `ReadableStream` */
function ensureGlobalReadableStream() {
    if (!globalThis.ReadableStream) {
        throw new TypeError('ReadableStream not provided by platform');
    }
    return globalThis.ReadableStream;
}

/** Convert a `wasi:http` `method` to a string */
function wasiHTTPMethodToString(wasiMethod: Method) {
    if (!wasiMethod?.tag) {
        throw new TypeError(
            'invalid wasi HTTP method variant, does not contain tag'
        );
    }
    switch (wasiMethod.tag) {
    case 'get':
    case 'head':
    case 'post':
    case 'put':
    case 'delete':
    case 'connect':
    case 'options':
    case 'trace':
    case 'patch':
        return wasiMethod.tag.toUpperCase();
    case 'other':
        if (!wasiMethod.val || typeof wasiMethod.val !== 'string') {
            throw new TypeError(
                "HTTP method variant 'other' with missing/invaldi payload"
            );
        }
        return wasiMethod.val;
    default:
        throw new TypeError(
            `unrecognized wasi HTTP method tag [${wasiMethod}]`
        );
    }
}

/**
 * Create a web-platform `Request` from a `wasi:http/incoming-handler` `incoming-request`.
 *
 * This method expects the `wasiIncomingRequest` object to be compliant with WASI 0.2.x,
 * with an implemention as generated by the jco/componentize-js JS ecosystem.
 *
 * @param {any} wasiIncomingRequest - request handler for a WASI HTTP request
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Request
 * @see https://github.com/WebAssembly/wasi-http
 */
export async function createWebPlatformRequest(wasiIncomingRequest: IncomingRequest) {
    // TODO: reuse bytes for subsequent web requests, doing pruning/growing where necessary
    // TODO: trailer support
    if (!wasiIncomingRequest) {
        throw new TypeError('WASI incoming request not provided');
    }
    const method = wasiHTTPMethodToString(wasiIncomingRequest.method());
    const pathWithQuery = wasiIncomingRequest.pathWithQuery();
    const scheme = wasiIncomingRequest.scheme();
    const authority = wasiIncomingRequest.authority();
    const decoder = new TextDecoder('utf-8');
    const headers = Object.fromEntries(
        wasiIncomingRequest.headers().entries().map(([k,valueBytes]) => {
            return [k, decoder.decode(valueBytes)];
        })
    );
    const Request = ensureGlobalRequest();
    const ReadableStream = ensureGlobalReadableStream();

    let incomingBody: IncomingBody;
    let incomingBodyStream: InputStream;
    let incomingBodyPollable: Pollable;
    const body = new ReadableStream({
        async pull(controller) {
            if (!incomingBody) {
                incomingBody = wasiIncomingRequest.consume();
                incomingBodyStream = incomingBody.stream();
                incomingBodyPollable = incomingBodyStream.subscribe();
            }

            // Read all information coming from the request
            while (true) {
                // Wait until the pollable is ready
                if (!incomingBodyPollable.ready()) {
                    incomingBodyPollable.block();
                }

                try {
                    const bytes = incomingBodyStream.read(
                        DEFAULT_INCOMING_BODY_READ_MAX_BYTES
                    );
                    if (bytes.length === 0) {
                        break;
                    } else {
                        controller.enqueue(bytes);
                    }
                } catch (err) {
                    console.error('error while reading bytes', err);
                    controller.close();
                    break;
                }
            }

            incomingBodyPollable[Symbol.dispose]();
            incomingBodyStream[Symbol.dispose]();
            incomingBody[Symbol.dispose]();
            controller.close();
        },
    });
    
    return new Request(`${scheme}://${authority}/${pathWithQuery}`, {
        method,
        headers,
        body,
    });
}
