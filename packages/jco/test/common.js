import { env } from 'node:process';
import { readdir, readFile } from 'node:fs/promises';
import { join } from 'node:path';
import { fileURLToPath, URL } from 'node:url';

import {
    componentNew,
    componentEmbed,
    transpile,
} from '@bytecodealliance/jco';

/**
 * Retrieve a list of all component fixtures
 *
 * Customize COMPONENT_FIXTURES env vars to use alternative test components
 *
 * COMPONENT_FIXTURES is a comma-separated list of component names ending in
 * ".component.wasm".
 *
 * Each of these components will then be passed through code generation and linting.
 *
 * If a local runtime host.ts file is present for the component name in test/runtime/[name]/host.ts
 * then the runtime test will be performed against that execution.
 *
 * When the runtime test is present, the flags in the runtime host.ts file will be used
 * as the flags of the code generation step.
 */
export async function getDefaultComponentFixtures() {
    return env.COMPONENT_FIXTURES
        ? env.COMPONENT_FIXTURES.split(',')
        : (await readdir('test/fixtures/components', { withFileTypes: true }))
            .filter(
                (f) => f.isFile() && f.name !== 'dummy_reactor.component.wasm'
            )
            .map((f) => f.name);
}

/** Path to ESLint as installed by npm-compatible tooling */
export const ESLINT_PATH = fileURLToPath(
    new URL('../../../node_modules/eslint/bin/eslint.js', import.meta.url)
);

export const AsyncFunction = (async () => {}).constructor;

/** Path to `tsc` binary as installed by npm-compatible tooling */
export const NODE_MODULES_TSC_BIN_PATH = fileURLToPath(
    new URL('../../../node_modules/typescript/bin/tsc', import.meta.url)
);

/** Path to Jco JS script */
export const JCO_JS_PATH = fileURLToPath(
    new URL('../src/jco.js', import.meta.url)
);

/** Path to fixture components */
export const COMPONENT_FIXTURES_DIR = fileURLToPath(
    new URL('./fixtures/components', import.meta.url)
);

/** Path to p3 related fixture components */
export const P3_COMPONENT_FIXTURES_DIR = join(COMPONENT_FIXTURES_DIR, 'p3');

/**
 * Run a transpile on a dummy WIT
 *
 * @param {object} args
 * @param {string} [args.witSource] - WIT file content
 * @param {string} [args.witPath] - path to a WIT file that can be loaded
 * @returns {Promise<Record<string, string>>} A Promise that resolves to files that were generated by transpiling,
 * with their contents converted to strings rather than being raw UTF8
 */
export async function transpileDummyWit(args) {
    const witPath = args?.witPath;
    let witSource = args?.witSource;
    if (!witSource && witPath) {
        witSource = await readFile(
            fileURLToPath(new URL(witPath, import.meta.url)),
            'utf8',
        );
    }
    if (!witSource) {
        throw new Error("failed to resolve witSource (neither witSource nor valid witPath provided)");
    }

    const component = await componentNew(
        await componentEmbed({
            witSource,
            dummy: true,
            metadata: [
                ['language', [['javascript', '']]],
                ['processed-by', [['dummy-gen', 'test']]],
            ],
        })
    );

    const { files } = await transpile(component, {
        name: 'component',
    });

    const decoder = new TextDecoder();
    for (const key of Object.keys(files)) {
        files[key] = decoder.decode(files[key]);
    }

    return {
        files,
    };
}
